<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IDV Assignment 3 — Jiaomei Shi</title>

  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "PingFang SC", "Microsoft YaHei", sans-serif;
      background: #eef4f4;
      margin: 0;
      padding: 32px;
    }
    h1 { margin: 0 0 8px 0; }
    .card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.06);
      padding: 20px;
      margin-bottom: 28px;
    }
    .note-block { margin: 40px 0; }
    .note-block p { margin: 4px 0 10px 0; }
  </style>
</head>
<body>

<h1>IDV Assignment 3 — Jiaomei Shi</h1>
<p class="note">This project replicates five reference charts using D3.js. Each chart includes at least one transition and one interaction, with notes describing the creation process and learning reflections.</p>

<script src="https://d3js.org/d3.v7.min.js"></script>

<!-- ================= Chart 1 ================= -->
<h2 style="margin-top:40px;">Chart 1 — Vector Space</h2>
<div id="chart1" class="card"></div>

<script>
const width1 = 880, height1 = 400;
const svg1 = d3.select("#chart1").append("svg").attr("width", width1).attr("height", height1);

// grid
for(let x=0;x<=width1;x+=50){svg1.append("line").attr("x1",x).attr("y1",0).attr("x2",x).attr("y2",height1).attr("stroke","#d0d0d0");}
for(let y=0;y<=height1;y+=50){svg1.append("line").attr("x1",0).attr("y1",y).attr("x2",width1).attr("y2",y).attr("stroke","#d0d0d0");}

// points
const pts1=[
 {x:300,y:100,l:"e¹α"},
 {x:200,y:120,l:"e²α"},
 {x:250,y:250,l:"e¹β"},
 {x:160,y:260,l:"e²β"}
];

svg1.selectAll("circle").data(pts1).enter().append("circle")
 .attr("cx",d=>d.x).attr("cy",d=>d.y).attr("r",5).attr("fill","#1b4393")
 .transition().duration(800).attr("r",8);

svg1.selectAll("circle")
 .on("mouseover",function(){d3.select(this).transition().duration(150).attr("r",12);})
 .on("mouseout",function(){d3.select(this).transition().duration(150).attr("r",8);});

svg1.selectAll("text").data(pts1).enter().append("text")
 .attr("x",d=>d.x+6).attr("y",d=>d.y-6).text(d=>d.l)
 .style("font-size","20px").style("font-family","Georgia")
 .style("opacity",0).transition().delay(400).duration(600).style("opacity",1);

// arrow head
svg1.append("defs").append("marker")
 .attr("id","arrow1").attr("viewBox","0 0 10 10").attr("refX",9).attr("refY",5)
 .attr("markerWidth",6).attr("markerHeight",6).attr("orient","auto-start-reverse")
 .append("path").attr("d","M 0 0 L 10 5 L 0 10 z").attr("fill","#1d4e89");

// links
const links1=[
 {from:pts1[0],to:pts1[2]},
 {from:pts1[1],to:pts1[3]},
 {from:pts1[1],to:pts1[0]},
 {from:pts1[3],to:pts1[2]}
];

links1.forEach(l=>{
 svg1.append("line")
 .attr("x1",l.from.x).attr("y1",l.from.y)
 .attr("x2",l.from.x).attr("y2",l.from.y)
 .attr("stroke","#1d4e89").attr("stroke-width",2)
 .attr("stroke-dasharray","6 4").attr("marker-end","url(#arrow1)")
 .on("mouseover",function(){d3.select(this).transition().duration(150).attr("stroke-width",5);})
 .on("mouseout",function(){d3.select(this).transition().duration(150).attr("stroke-width",2);})
 .transition().duration(800)
 .attr("x2",l.to.x).attr("y2",l.to.y);
});
</script>

<div class="note-block">
  <h3>Notes for Chart 1 — Vector Space</h3>
  <p><strong>Observation:</strong> The reference chart presents a simple 2D vector space with labeled vectors and directional arrows. It emphasizes spatial relationship rather than numerical scale.</p>
  <p><strong>Implementation:</strong> I created an SVG grid and placed four labeled vectors. The connecting dashed lines are animated and change thickness on hover to highlight interactivity.</p>
  <p><strong>Reflection:</strong> Through this chart, I learned how D3 handles coordinate-based vector representation. The smooth transitions help make geometric relationships visually clear.</p>
</div>

<!-- ================= Chart 2 ================= -->
<h2 style="margin-top:40px;">Chart 2 — Word Network</h2>
<div id="chart2" class="card"></div>

<script>
const width2=880,height2=400;
const svg2=d3.select("#chart2").append("svg").attr("width",width2).attr("height",height2);

const words2=[
 {id:"strike",x:200,y:100},{id:"protest",x:150,y:180},{id:"riot",x:250,y:180},{id:"crowd",x:200,y:260},
 {id:"earthquake",x:550,y:100},{id:"tsunami",x:500,y:180},{id:"collapse",x:600,y:180},{id:"tremor",x:650,y:260},{id:"shaking",x:700,y:120}
];

const links2=[
 ["strike","protest"],["strike","crowd"],["riot","protest"],["riot","crowd"],
 ["earthquake","tsunami"],["earthquake","shaking"],["tsunami","collapse"],["collapse","tremor"],["shaking","tremor"]
];

links2.forEach(l=>{
 const a=words2.find(w=>w.id===l[0]);
 const b=words2.find(w=>w.id===l[1]);
 svg2.append("line")
 .attr("x1",a.x).attr("y1",a.y)
 .attr("x2",b.x).attr("y2",b.y)
 .attr("stroke","#1864ab").attr("stroke-width",2).attr("stroke-dasharray","5 3")
 .on("mouseover",function(){d3.select(this).transition().duration(120).attr("stroke-width",4);})
 .on("mouseout",function(){d3.select(this).transition().duration(120).attr("stroke-width",2);});
});

svg2.selectAll("text").data(words2).enter().append("text")
 .text(d=>d.id).attr("x",d=>d.x).attr("y",d=>d.y)
 .style("font-size","16px").style("fill","#1864ab")
 .style("opacity",0).transition().duration(600).style("opacity",1);
</script>

<div class="note-block">
  <h3>Notes for Chart 2 — Word Network</h3>
  <p><strong>Observation:</strong> This network connects related words into clusters, reflecting semantic relationships.</p>
  <p><strong>Implementation:</strong> I manually positioned words and linked them using dashed lines. Hovering over a link increases its stroke width, and all labels fade in gradually.</p>
  <p><strong>Reflection:</strong> This chart reinforced how D3 can visually structure abstract data. Even subtle transitions make relationships easier to interpret.</p>
</div>

<!-- ================= Chart 3 ================= -->
<h2 style="margin-top:40px;">Chart 3 — Optimization Route</h2>
<div id="chart3" class="card"></div>

<script>
const width3=880,height3=400;
const svg3=d3.select("#chart3").append("svg").attr("width",width3).attr("height",height3);

const route3=[
 {x:200,y:350},{x:220,y:300},{x:250,y:250},{x:300,y:200},
 {x:350,y:180},{x:400,y:200},{x:450,y:220},{x:500,y:230},
 {x:550,y:240},{x:600,y:245},{x:650,y:250}
];

const path3 = svg3.append("path")
 .attr("fill","none").attr("stroke","#1864ab").attr("stroke-width",2).attr("stroke-dasharray","5 3")
 .attr("d",d3.line().x(d=>d.x).y(d=>d.y)(route3));

const L3 = path3.node().getTotalLength();
path3.attr("stroke-dasharray", L3 + " " + L3)
 .attr("stroke-dashoffset", L3)
 .transition().duration(1200).ease(d3.easeCubicInOut)
 .attr("stroke-dashoffset", 0);
</script>

<div class="note-block">
  <h3>Notes for Chart 3 — Optimization Route</h3>
  <p><strong>Observation:</strong> The chart visualizes a progression path as an optimization process.</p>
  <p><strong>Implementation:</strong> A dashed line was created using <code>d3.line()</code>, and its stroke-dash offset was animated to make the path appear progressively.</p>
  <p><strong>Reflection:</strong> This method taught me how to use path animation to convey direction, process, and convergence in a single visual flow.</p>
</div>

<!-- ================= Chart 4 ================= -->
<h2 style="margin-top:40px;">Chart 4 — Cluster Scatter</h2>
<div id="chart4" class="card"></div>

<script>
const width4=880,height4=400;
const svg4=d3.select("#chart4").append("svg").attr("width",width4).attr("height",height4);

const cA=d3.range(30).map(()=>({x:200+Math.random()*60,y:180+Math.random()*60}));
const cB=d3.range(30).map(()=>({x:550+Math.random()*60,y:180+Math.random()*60}));
const pts4=cA.concat(cB);

svg4.selectAll("circle").data(pts4).enter().append("circle")
 .attr("cx",d=>d.x).attr("cy",d=>d.y-20).attr("r",4).attr("fill","#7e57c2").attr("opacity",0)
 .on("mouseover",function(){d3.select(this).transition().duration(120).attr("r",10);})
 .on("mouseout",function(){d3.select(this).transition().duration(120).attr("r",4);})
 .transition().duration(600).attr("cy",d=>d.y).attr("opacity",0.85);
</script>

<div class="note-block">
  <h3>Notes for Chart 4 — Cluster Scatter</h3>
  <p><strong>Observation:</strong> The scatter plot represents two data clusters illustrating separation and similarity.</p>
  <p><strong>Implementation:</strong> Two random clusters were generated and animated with a drop-and-fade transition. Hovering on points enlarges them for interactive feedback.</p>
  <p><strong>Reflection:</strong> I learned how animation and interactivity can highlight clustering patterns, making statistical visuals more dynamic and intuitive.</p>
</div>

<!-- ================= Chart 5 ================= -->
<h2 style="margin-top:40px;">Chart 5 — Mixed Math Plots</h2>
<div id="chart5" class="card"></div>

<script>
const width5=880,height5=400;
const svg5=d3.select("#chart5").append("svg").attr("width",width5).attr("height",height5);

// left bars
svg5.append("rect").attr("x",200).attr("y",200).attr("width",30).attr("height",150).attr("fill","#b79dd6");
svg5.append("rect").attr("x",235).attr("y",150).attr("width",30).attr("height",200).attr("fill","#b79dd6");
svg5.append("text").attr("x",200).attr("y",380).text("i/n").style("font-size","14px");
svg5.append("text").attr("x",235).attr("y",380).text("(i+Δn)/n").style("font-size","14px");
svg5.append("text").attr("x",280).attr("y",380).text("1").style("font-size","14px");

// right lines
const line1=[{x:500,y:120},{x:650,y:140},{x:800,y:200}];
svg5.append("path").classed("plot-line",true)
 .attr("fill","none").attr("stroke","#3b7e3b").attr("stroke-width",3)
 .attr("d",d3.line().x(d=>d.x).y(d=>d.y)(line1));

const line2=[{x:500,y:200},{x:650,y:260},{x:800,y:300}];
svg5.append("path").classed("plot-line",true)
 .attr("fill","none").attr("stroke","#a8d5a2").attr("stroke-width",2)
 .attr("stroke-dasharray","5 5")
 .attr("d",d3.line().x(d=>d.x).y(d=>d.y)(line2));

svg5.selectAll("path.plot-line").each(function(_,i){
 const p=d3.select(this);
 const L=this.getTotalLength();
 p.attr("stroke-dasharray",L+" "+L)
  .attr("stroke-dashoffset",L)
  .transition().delay(i*200).duration(1000)
  .attr("stroke-dashoffset",0);
});
</script>

<div class="note-block">
  <h3>Notes for Chart 5 — Mixed Math Plots</h3>
  <p><strong>Observation:</strong> The chart combines discrete bar comparisons with continuous curve trends, reflecting mathematical relationships between discrete and continuous data.</p>
  <p><strong>Implementation:</strong> Left-side bars visualize the Δn step, while two right-side lines (solid and dashed) simulate functions and are animated progressively.</p>
  <p><strong>Reflection:</strong> Integrating both forms deepened my understanding of how D3 unifies multiple mathematical expressions in one canvas. The progressive drawing conveys flow and continuity.</p>
</div>

<!-- ================= Process Reflection ================= -->
<h2 style="margin-top:50px;">Process Reflection — How These Charts Were Created</h2>
<div class="card">
  <p><strong>Step-by-step approach:</strong> I began by reviewing the reference charts and breaking them into basic visual elements such as points, lines, or paths. I then reconstructed each using D3.js primitives (<code>rect</code>, <code>line</code>, <code>circle</code>, <code>path</code>), verifying each part visually before adding transitions or interactivity.</p>
  <p><strong>Chatbot collaboration:</strong> Throughout this process, I discussed my progress and troubleshooting steps with ChatGPT. The chatbot helped debug syntax issues, explain <code>stroke-dasharray</code> animations, and refine transition effects. It also suggested narrative structuring for the notes and recommended using "Observation / Implementation / Reflection" to improve academic clarity.</p>
  <p><strong>Intermediate results:</strong> I tested each chart incrementally—first drawing static shapes, then applying transitions, and finally adding hover interactivity. This iterative testing approach allowed me to debug gradually rather than all at once.</p>
  <p><strong>Reflection:</strong> This project helped me understand not only D3 syntax and SVG manipulation but also the design thinking behind data visualization: clarity, interactivity, and progressive refinement. Working with ChatGPT simulated a collaborative design-learning workflow, similar to pair programming but focused on creative visualization.</p>
</div>

</body>
</html>
